## Overview

Приложение предназначено для хранения пользовательских аккаунтов и связанных с ними данных, включая чувствительную информацию.

Система реализована по модели клиент–сервер: клиентом выступает Telegram-бот, сервер предоставляет API для аутентификации и хранения данных. Все чувствительные данные шифруются на стороне клиента до отправки на сервер; сервер работает исключительно с зашифрованными данными и не имеет доступа к их содержимому.

Механизмы аутентификации и управления сессией отделены от доступа к зашифрованным данным. Наличие активной сессии подтверждает личность пользователя, однако доступ к секретной информации требует отдельного криптографического подтверждения.

## Architecture

### System Architecture
Система построена по модели клиент–сервер. Клиентское приложение (Telegram-бот)
отвечает за пользовательское взаимодействие и выполнение криптографических
операций, сервер предоставляет API для аутентификации и хранения данных.

### Server Architecture
Серверная часть реализована как монолитное приложение, что соответствует
текущей сложности системы и упрощает сопровождение и развитие проекта.
Внутренняя структура приложения ориентирована на низкую связанность компонентов.

## Architecture

Архитектура проекта организована по уровням, отражающим систему, серверное приложение и клиентский бот.

### System Level
Система построена по модели клиент–сервер: клиент — Telegram-бот, сервер предоставляет API для аутентификации и хранения данных. Клиент и сервер разворачиваются как независимые приложения и взаимодействуют по HTTP API.

### Server Architecture
Серверное приложение (`app`) реализовано как монолитное приложение, что соответствует текущей сложности системы и упрощает сопровождение и развитие проекта.  

Внутренняя структура приложения организована по принципам Clean Architecture с разделением ответственности:

- **domain** — доменная модель и бизнес-правила  
- **services** — сценарии использования и координация бизнес-логики  
- **adapters** — работа с базой данных и внешними сервисами  
- **endpoints** — HTTP API  

Некоторые инфраструктурные компоненты вынесены в `shared/adapters` и используются как сервером, так и клиентским ботом, при этом зависимости направлены **от внешних слоёв к доменному ядру**, что упрощает тестирование, поддержку и развитие.

### Bot Architecture
Telegram-бот (`bot`) также имеет внутреннюю организацию, аналогичную Clean Architecture, с разделением логики:

- **dialog** — сценарии взаимодействия с пользователем  
- **handlers** — обработка событий и команд Telegram API  
- **services** — координация бизнес-логики и взаимодействия с сервером  
- **utils** — вспомогательные функции и утилиты  

Бот использует инфраструктурные адаптеры из `shared/adapters` для повторного использования общих компонентов.

### Dependencies
Все зависимости направлены **к ядру доменной логики**, что гарантирует:

- изоляцию бизнес-логики от инфраструктурных деталей  
- лёгкость тестирования и поддержки  
- возможность отдельного масштабирования компонентов в будущем без изменения бизнес-правил


## Security Model
Приложение спроектировано с упором на минимизацию доверия к серверу и
ограничение последствий компрометации инфраструктуры.

### Authentication

Для аутентификации пользователей используется пароль, который:
- никогда не хранится и не передаётся в открытом виде;
- хэшируется;
- применяется исключительно для проверки подлинности пользователя.

Сервер хранит только хэш пароля и не имеет возможности восстановить
оригинальное значение.

### Session Management

Сессия пользователя реализована с использованием JWT:
- access-токены имеют ограниченное время жизни;
- refresh-токены используются для обновления access-токенов;
- активные токены хранятся в Redis.

Компрометация токена не предоставляет доступа к расшифрованным пользовательским данным.

### Data Encryption

Секретные данные пользователей хранятся в зашифрованном виде.

Ключи шифрования:
- не хранятся в базе данных;
- не вычисляются и не передаются на сервер;
- производятся на стороне клиента на основе пользовательского пароля
  с использованием алгоритмов выработки ключа и индивидуальной соли.

Сервер оперирует исключительно зашифрованными данными и не имеет доступа
к ключам шифрования или расшифрованному содержимому.

### Key Lifetime and Re-Verification

Ключи шифрования имеют ограниченное время жизни и хранятся временно
в изолированном клиентском хранилище с TTL.

По истечении времени жизни ключа для доступа к секретным данным
требуется повторный ввод пользовательского пароля, даже при наличии
активной пользовательской сессии.

Это позволяет разделить:
- аутентификацию пользователя;
- доступ к расшифрованным данным.

### Threat Model Summary

Даже в случае компрометации:
- базы данных;
- сервера приложений;
- access или refresh токенов;

злоумышленник не получает доступа к пользовательским секретным данным
без знания пользовательского пароля.



